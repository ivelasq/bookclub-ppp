[
  {
    "objectID": "03_notes.html",
    "href": "03_notes.html",
    "title": "5  Notes",
    "section": "",
    "text": "To write better programs, we want to understand how to:"
  },
  {
    "objectID": "03_notes.html#scripting",
    "href": "03_notes.html#scripting",
    "title": "5  Notes",
    "section": "5.1 Scripting",
    "text": "5.1 Scripting\nA script is a program that runs a series of statements and stops.\n\nOrder is important. Put definitions of variables and functions near the top.\nNames must always be defined before they are used.\n\n\ndef square(x):\n    return x*x\n\na = 42\nb = a + 2     # Requires that `a` is defined\n\nz = square(b) # Requires `square` and `b` to be defined\n\n\n5.1.1 Functions\nA function is a named sequence of statements.\nWhy?\n\nUse a function to put all of the code related to a single task all in one place.\nFunctions simplify complex operations.\nThey also simplify repeated operations.\n\nHow?\n\nLike variables, define functions prior to actually being used (or called) during program execution.\n\nBest practices\n\nUse a “bottom-up” style: the smaller/simpler functions go at the top of your script.\nFunctions should only operate on passed inputs and avoid global variables and mysterious side-effects.\nUse a ‘doc-string’ to include documentation for your function. Include at least a short one sentence summary of what the function does.\nUse type annotations to inform users about function definitions.\n\n\n# define function\ndef read_prices(filename: str) -> dict: # type annotation\n    # add documentation\n    ''' \n    Read prices from a CSV file of name,price data\n    '''\n    prices = {}\n    with open(filename) as f:\n        f_csv = csv.reader(f)\n        for row in f_csv:\n            prices[row[0]] = float(row[1])\n    return prices"
  },
  {
    "objectID": "03_notes.html#more-on-functions",
    "href": "03_notes.html#more-on-functions",
    "title": "5  Notes",
    "section": "5.2 More on Functions",
    "text": "5.2 More on Functions\n\n5.2.1 Calling a function\n\nPositional arguments prices = read_prices('prices.csv', True)\nKeyword arguments prices = read_prices(filename='prices.csv', debug=True)\n\n\n\n5.2.2 Default arguments\n\nDefine a default that needs to be overwritten\nAll non-optional arguments go first\nKeyword arguments improve code clarity\nAlways give short, but meaningful names to functions arguments\n\ndefault: def read_prices(filename, debug=False)\noptional argument: d = read_prices('prices.csv')\noverride argument: e = read_prices('prices.dat', True)\neven better override argument: d = read_prices('prices.csv', debug=True)\n\n\n5.2.3 Returning values\n\nThe return statement returns a value.\n\n\ndef square(x):\n    return x * x\n\nsquare(2)\n\n4\n\n\n\nIf no return value is given or return is missing, None is returned.\n\n\ndef square(x):\n    x * x\n\nsquare(2)\n\nFunctions can only return one value OR return them in a tuple.\n\ndef divide(a,b):\n    q = a // b      # Quotient\n    r = a % b       # Remainder\n    return q, r     # Return a tuple\n\nd = x, y = divide(37,5) # x = 7, y = 2\n# why doesn't it return without object?\nd\n\n(7, 2)\n\n\n\n\n5.2.4 Variable scope\nVariables assignments occur outside and inside function definitions. * Variables defined outside are “global”. - Functions can freely access the values of globals defined in the same file. - However, functions cannot modify globals. * Variables inside a function are “local”. - Local variables are not retained or accessible after the function call.\n\ndef greeting():\n    name = 'Dave' # Using `name` local variable\n    print('Hello', name)  \n    \ngreeting()\n\nHello Dave\n\n\n\nname = 'Dave'\n\ndef greeting():\n    print('Hello', name)  # Using `name` global variable\n\ngreeting()\n\nHello Dave\n\n\n\n\n5.2.5 Argument passing\n\nValues are not copies\nCan be modified in-place\nVariable assignment never overwrites memory. The name is merely bound to a new value.\n\n\ndef foo(items):\n    items.append(42)    # Modifies the input object\n\na = [1, 2, 3]\nfoo(a)\nprint(a)                # [1, 2, 3, 42]\n\n[1, 2, 3, 42]\n\n\n\ndef bar(items):\n    items = [4,5,6]    # Changes local `items` variable to point to a different object\n\nb = [1, 2, 3]\nbar(b)\nprint(b)                # [1, 2, 3]\n\n[1, 2, 3]"
  },
  {
    "objectID": "03_exercises.html",
    "href": "03_exercises.html",
    "title": "7  Exercises",
    "section": "",
    "text": "# fileparse.py\nimport csv\n\ndef parse_csv(filename):\n    '''\n    Parse a CSV file into a list of records\n    '''\n    with open(filename) as f:\n        rows = csv.reader(f)\n\n        # Read the file headers\n        headers = next(rows)\n        records = []\n        for row in rows:\n            if not row:    # Skip rows with no data\n                continue\n            record = dict(zip(headers, row))\n            records.append(record)\n\n    return records\n\n\nportfolio = parse_csv('Data/portfolio.csv')\nportfolio"
  },
  {
    "objectID": "03_exercises.html#exercise-3.4-building-a-column-selector",
    "href": "03_exercises.html#exercise-3.4-building-a-column-selector",
    "title": "7  Exercises",
    "section": "7.2 Exercise 3.4: Building a Column Selector",
    "text": "7.2 Exercise 3.4: Building a Column Selector\nModify the parse_csv() function so that it optionally allows user-specified columns to be picked out.\n\ndef parse_csv(filename, select=None):\n    '''\n    Parse a CSV file into a list of records\n    '''\n    with open(filename) as f:\n        rows = csv.reader(f)\n\n        # Read the file headers\n        headers = next(rows)\n\n        # If a column selector was given, find indices of the specified columns.\n        # Also narrow the set of headers used for resulting dictionaries\n        if select:\n            indices = [headers.index(colname) for colname in select]\n            headers = select\n        else:\n            indices = []\n\n        records = []\n        for row in rows:\n            if not row:    # Skip rows with no data\n                continue\n            # Filter the row if specific columns were selected\n            if indices:\n                row = [ row[index] for index in indices ]\n\n            # Make a dictionary\n            record = dict(zip(headers, row))\n            records.append(record)\n\n    return records\n\n\nshares_held = parse_csv('Data/portfolio.csv', select=['name','shares'])\nshares_held"
  },
  {
    "objectID": "03_exercises.html#exercise-3.5-performing-type-conversion",
    "href": "03_exercises.html#exercise-3.5-performing-type-conversion",
    "title": "7  Exercises",
    "section": "7.3 Exercise 3.5: Performing Type Conversion",
    "text": "7.3 Exercise 3.5: Performing Type Conversion\nModify the parse_csv() function so that it can work with such files by creating a list of tuples instead.\n\ndef parse_csv(filename, select=None, types=None):\n    '''\n    Parse a CSV file into a list of records\n    '''\n    with open(filename) as f:\n        rows = csv.reader(f)\n\n        # Read the file headers\n        headers = next(rows)\n\n        # If a column selector was given, find indices of the specified columns.\n        # Also narrow the set of headers used for resulting dictionaries\n        if select:\n            indices = [headers.index(colname) for colname in select]\n            headers = select\n        else:\n            indices = []\n\n        records = []\n        for row in rows:\n            if not row:    # Skip rows with no data\n                continue\n            \n            # Filter the row if specific columns were selected\n            if indices:\n                row = [ row[index] for index in indices ]\n            \n            if types:\n                row = [func(val) for func, val in zip(types, row) ]\n\n            # Make a dictionary\n            record = dict(zip(headers, row))\n            records.append(record)\n\n    return records\n\n\nportfolio = parse_csv('Data/portfolio.csv', types=[str, int, float])\nportfolio"
  },
  {
    "objectID": "03_exercises.html#exercise-3.6-working-without-headers",
    "href": "03_exercises.html#exercise-3.6-working-without-headers",
    "title": "7  Exercises",
    "section": "7.4 Exercise 3.6: Working without Headers",
    "text": "7.4 Exercise 3.6: Working without Headers\nModify the parse_csv() function so that it can work with such files by creating a list of tuples instead.\n\n# fileparse.py\nimport csv\n\ndef parse_csv(filename, select=None, types=None, has_headers=True, delimiter=','):\n    '''\n    Parse a CSV file into a list of records with type conversion.\n    '''\n    with open(filename) as f:\n        rows = csv.reader(f, delimiter=delimiter)\n\n        # If has headers, use next(rows), otherwise blank\n        if has_headers:\n            headers = next(rows)\n        else:\n            headers = []\n\n        # If specific columns have been selected, make indices for filtering \n        if select:\n            indices = [ headers.index(colname) for colname in select ]\n            headers = select\n\n        records = []\n        for row in rows:\n            if not row:     # Skip rows with no data\n                continue\n\n            # If specific column indices are selected, pick them out\n            if select:\n                row = [ row[index] for index in indices]\n\n            # Apply type conversion to the row\n            if types:\n                row = [func(val) for func, val in zip(types, row)]\n\n            # Make a dictionary or a tuple\n            if headers:\n                record = dict(zip(headers, row))\n            else:\n                record = tuple(row)\n            records.append(record)\n\n        return records\n\n\nprices = parse_csv('Data/prices.csv', types=[str,float], has_headers=False)\nprices\n\n[('AA', 9.22),\n ('AXP', 24.85),\n ('BA', 44.85),\n ('BAC', 11.27),\n ('C', 3.72),\n ('CAT', 35.46),\n ('CVX', 66.67),\n ('DD', 28.47),\n ('DIS', 24.22),\n ('GE', 13.48),\n ('GM', 0.75),\n ('HD', 23.16),\n ('HPQ', 34.35),\n ('IBM', 106.28),\n ('INTC', 15.72),\n ('JNJ', 55.16),\n ('JPM', 36.9),\n ('KFT', 26.11),\n ('KO', 49.16),\n ('MCD', 58.99),\n ('MMM', 57.1),\n ('MRK', 27.58),\n ('MSFT', 20.89),\n ('PFE', 15.19),\n ('PG', 51.94),\n ('T', 24.79),\n ('UTX', 52.61),\n ('VZ', 29.26),\n ('WMT', 49.74),\n ('XOM', 69.35)]"
  },
  {
    "objectID": "03_exercises.html#exercise-3.7-picking-a-different-column-delimitier",
    "href": "03_exercises.html#exercise-3.7-picking-a-different-column-delimitier",
    "title": "7  Exercises",
    "section": "7.5 Exercise 3.7: Picking a different column delimitier",
    "text": "7.5 Exercise 3.7: Picking a different column delimitier\nModify your parse_csv() function so that it also allows the delimiter to be changed.\n\n# fileparse.py\nimport csv\n\ndef parse_csv(filename, select=None, types=None, has_headers=True, delimiter=','):\n    '''\n    Parse a CSV file into a list of records with type conversion.\n    '''\n    with open(filename) as f:\n        rows = csv.reader(f, delimiter=delimiter)\n\n        # If has headers, use next(rows), otherwise blank\n        if has_headers:\n            headers = next(rows)\n        else:\n            headers = []\n\n        # If specific columns have been selected, make indices for filtering \n        if select:\n            indices = [ headers.index(colname) for colname in select ]\n            headers = select\n\n        records = []\n        for row in rows:\n            if not row:     # Skip rows with no data\n                continue\n\n            # If specific column indices are selected, pick them out\n            if select:\n                row = [ row[index] for index in indices]\n\n            # Apply type conversion to the row\n            if types:\n                row = [func(val) for func, val in zip(types, row)]\n\n            # Make a dictionary or a tuple\n            if headers:\n                record = dict(zip(headers, row))\n            else:\n                record = tuple(row)\n            records.append(record)\n\n        return records"
  },
  {
    "objectID": "03_notes.html#error-checking",
    "href": "03_notes.html#error-checking",
    "title": "5  Notes",
    "section": "5.3 Error Checking",
    "text": "5.3 Error Checking\n\nPython performs no checking or validation of function argument types or values.\nErrors appear at run time.\n\n\n5.3.1 Exceptions\n\nUse raise to raise exceptions.\nExceptions have an associated value (f'{name} not authorized' below).\n\n“Don’t catch exceptions. Fail fast and loud. If it’s important, someone else will take care of the problem. Only catch an exception if you are that someone. That is, only catch errors where you can recover and sanely keep going.”\n\nauthorized = [\"Alpha\", \"Bravo\", \"Delta\"]\n\nif name not in authorized:\n    raise RuntimeError(f'{name} not authorized')\n\nRuntimeError: Dave not authorized\n\n\n\n\n5.3.2 Exception Handling\n\nUse try-except to catch exceptions.\nExceptions propagate to the first matching except.\nSee built-in exceptions.\n\n\ndef grok():\n    ...\n    raise RuntimeError('Whoa!')   # Exception raised here\n\ndef spam():\n    grok()                        # Call that will raise exception\n\ndef bar():\n    try:\n       spam()\n    except RuntimeError as e:     # Exception caught here\n        ...\n\ndef foo():\n    try:\n         bar()\n    except RuntimeError as e:     # Exception does NOT arrive here\n        ...\n\nfoo()\n\n\n\n5.3.3 Catching Multiple Errors\n\nYou can catch different kinds of exceptions using multiple except blocks.\n\n\ntry:\n  ...\nexcept LookupError as e:\n  ...\nexcept RuntimeError as e:\n  ...\nexcept IOError as e:\n  ...\nexcept KeyboardInterrupt as e:\n  ...\n\n\n\n5.3.4 Catching All Errors\n\nThis method tells you the reason something failed.\n\n\ntry:\n    go_do_something()\nexcept Exception as e:\n    print('Computer says no. Reason :', e)\n\nComputer says no. Reason : name 'go_do_something' is not defined\n\n\n\n\n5.3.5 finally and with statements\n\nSpecifies code that must run regardless of whether or not an exception occurs.\n\nlock = Lock()\n...\nlock.acquire()\ntry:\n    ...\nfinally:\n    lock.release()  # this will ALWAYS be executed. With and without exception.\n\nIn modern code, try-finally is often replaced with the with statement.\n\nlock = Lock()\nwith lock:\n    # lock acquired\n    ...\n# lock released"
  },
  {
    "objectID": "03_notes.html#exception-values",
    "href": "03_notes.html#exception-values",
    "title": "5  Notes",
    "section": "5.4 Exception Values",
    "text": "5.4 Exception Values"
  },
  {
    "objectID": "03_exercises.html#exercise-3.8-raising-exceptions",
    "href": "03_exercises.html#exercise-3.8-raising-exceptions",
    "title": "7  Exercises",
    "section": "7.6 Exercise 3.8: Raising exceptions",
    "text": "7.6 Exercise 3.8: Raising exceptions\nModify the code so that an exception gets raised if both the select and has_headers=False arguments are passed.\n\n# fileparse.py\nimport csv\n\ndef parse_csv(filename, select=None, types=None, has_headers=True, delimiter=',', silence_errors=False):\n    '''\n    Parse a CSV file into a list of records with type conversion.\n    '''\n    if select and not has_headers:\n        raise RuntimeError('select requires column headers')\n\n    with open(filename) as f:\n        rows = csv.reader(f, delimiter=delimiter)\n\n        # Read the file headers (if any)\n        headers = next(rows) if has_headers else []\n\n        # If specific columns have been selected, make indices for filtering and set output columns\n        if select:\n            indices = [ headers.index(colname) for colname in select ]\n            headers = select\n\n        records = []\n        for rowno, row in enumerate(rows, 1):\n            if not row:     # Skip rows with no data\n                continue\n\n            # If specific column indices are selected, pick them out\n            if select:\n                row = [ row[index] for index in indices]\n\n            # Apply type conversion to the row\n            if types:\n                try:\n                    row = [func(val) for func, val in zip(types, row)]\n                except ValueError as e:\n                    if not silence_errors:\n                        print(f\"Row {rowno}: Couldn't convert {row}\")\n                        print(f\"Row {rowno}: Reason {e}\")\n                    continue\n\n            # Make a dictionary or a tuple\n            if headers:\n                record = dict(zip(headers, row))\n            else:\n                record = tuple(row)\n            records.append(record)\n\n        return records"
  },
  {
    "objectID": "03_exercises.html#exercise-3.9-catching-exceptions",
    "href": "03_exercises.html#exercise-3.9-catching-exceptions",
    "title": "7  Exercises",
    "section": "7.7 Exercise 3.9: Catching exceptions",
    "text": "7.7 Exercise 3.9: Catching exceptions\nModify the parse_csv() function to catch all ValueError exceptions generated during record creation and print a warning message for rows that can’t be converted."
  },
  {
    "objectID": "03_exercises.html#exercise-3.10-silencing-errors",
    "href": "03_exercises.html#exercise-3.10-silencing-errors",
    "title": "7  Exercises",
    "section": "7.8 Exercise 3.10: Silencing Errors",
    "text": "7.8 Exercise 3.10: Silencing Errors\nModify the parse_csv() function so that parsing error messages can be silenced if explicitly desired by the user."
  },
  {
    "objectID": "03_notes.html#modules",
    "href": "03_notes.html#modules",
    "title": "5  Notes",
    "section": "5.4 Modules",
    "text": "5.4 Modules\n\nAny Python source file is a module (file = module).\nThe import statement loads and executes a module: import foo.\n\n\n5.4.1 Namespace\nA module is sometimes said to be a namespace. The module name is directly tied to the file name.\n\nThe module name is used as a prefix: a = foo.grok(2)\nThe names are all of the global variables and functions defined in the source file.\nYou can refer to a variable of the same name if in two different modules (modules are isolated).\nEach module is its own little universe (global variables are always bound to the enclosing module).\n\n\n\n5.4.2 Module execution\nWhen a module is imported, all of the statements in the module execute one after another until the end of the file is reached.\n\n5.4.2.1 import as statement\nYou can change the name of a module as you import it: import pandas as pd\n\nEach module loads and executes only once.\nPython consults a path list (sys.path) when looking for modules. This can be adjusted.\n\n\n\n5.4.2.2 from module import\nThis picks certain statements from a module rather than all of them: from math import sin, cos\nVariations on import do not change the way that modules work."
  },
  {
    "objectID": "03_notes.html#main-module",
    "href": "03_notes.html#main-module",
    "title": "5  Notes",
    "section": "5.5 Main Module",
    "text": "5.5 Main Module\nThe main module is the source file that runs first.\nAny Python file can either run as main or as a library import.\nbash % python3 prog.py # Running as main\nimport prog   # Running as library import\nUsually, you don’t want statements that are part of the main program to execute on a library import.\nif __name__ == '__main__':\n    # Does not execute if loaded with import ...\n\n5.5.1 Command Line\nPython is often used for command-line tools.\n\nThe command line is a list of text strings: bash % python3 report.py portfolio.csv prices.csv\n\n\n\n5.5.2 Standard S/I\nStandard Input / Output (or stdio) are files that work the same as normal files.\n\nPrint is directed to sys.stdout\nInput is read from sys.stderr\nTracebacks and errors are directed to sys.stdin\n\n\n\n5.5.3 Environment Variables\n\nEnvironment variables are set in the shell: bash % setenv NAME dave\nos.environ is a dictionary that contains these values.\n\nimport os\n\nname = os.environ['NAME'] # 'dave'\n\n\n5.5.4 Program Exit\nProgram exit is handled through exceptions: raise SystemExit."
  },
  {
    "objectID": "03_notes.html#design-discussion",
    "href": "03_notes.html#design-discussion",
    "title": "5  Notes",
    "section": "5.6 Design Discussion",
    "text": "5.6 Design Discussion\n\n5.6.1 Filenames versus Iterables\n\nWhich of these functions do you prefer? Why?\nWhich of these functions is more flexible?\n\nOption 1:\n# Provide a filename\ndef read_data(filename):\n    records = []\n    with open(filename) as f:\n        for line in f:\n            ...\n            records.append(r)\n    return records\n\nd = read_data('file.csv')\nOption 2:\n# Provide lines\ndef read_data(lines):\n    records = []\n    for line in lines:\n        ...\n        records.append(r)\n    return records\n\nwith open('file.csv') as f:\n    d = read_data(f)\nDuck typing: If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\nIn the second version of read_data() above, the function expects any iterable object, not just the lines of a file. There is considerable flexibility with this design. Question: Should we embrace or fight this flexibility?"
  }
]